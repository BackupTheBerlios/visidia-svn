
\newpage
\section{Création et utilisation d'arêtes orientées pour former un cycle}

En permettant la saisie d'arêtes orientées, ViSiDia fournit à l'utilisateur le moyen de tracer dans le graphe un cycle orienté pour simuler des algorithmes de type Diskjtra.
Cette partie présente d'une part comment orienter des arêtes pour définir un cycle orienté, et d'autre part qu'elles sont les méthodes permettant d'implémenter un algorithme tel que Diskjtra qui utilisent ce cycle orienté.

\subsection{Création d'arêtes orientées}

Avant toute orientation, l'utilisateur doit éditer complètement le graphe. Il faut que toutes les arêtes aient été saisies en tant qu'arêtes non-orientées, l'orientation s'effectuant ensuite.

\subsubsection{Comment changer le mode de création}
Par défaut, les arêtes creées sont non-orientées.\\
Pour modifier le mode de création il faut dans l'éditeur de graphes choisir {\bf Change edges shape} dans le menu {\bf Transformation}, sélectionner le type d'arête à tracer puis valider avec OK.\\\\ 

\includegraphics[scale=.4]{fig1.eps}

{\it Transformation - Change edges shape}\\


\subsubsection{Passage d'une arête non-orientée à une arête orientée} 

Le graphe non-orienté est saisi, Il faut maintenant changer le mode de création d'arêtes comme il est indiqué précedemment.
Ensuite, il suffit de ``re-creer'' l'arête de façon habituelle:
\begin{itemize}
\item Sélectionner le sommet d'origine en maintenant enfoncé le bouton gauche de la souris
\item Faire glisser le curseur jusqu'au sommet de destination (en recouvrant une arête non-orientée), et lacher le bouton gauche.
\end{itemize}

Chaque fois qu'une arête est orientée, au sommet d'origine {\it est associé} un sommet {\it suivant} qui est le sommet destination, et à ce dernier {\it est associé} un sommet {\it précédent}: l'origine.

\subsubsection{Passage d'une arête orientée à une arête non-orientée}

Il faut obligatoirement suivre cette démarche:
\begin{itemize}
\item Effacer l'arête orientée
\item Re-creer l'arête en mode non-orienté.  
\end{itemize}

\subsubsection{Contraintes à respecter}

Les orientations ne sont valides que si elles définissent un cycle (pas nécessairement recouvrant) ou des parties de cycle.\\
Autrement dit, les cas de divergence et de convergence d'arêtes orientées induisent un comportement inopportaint lors d'une simulation.\\
Par exemple, dans un cas de divergence où plusieurs arêtes orientées partent d'un même sommet, alors son noeud {\it suivant} sera celui de la dernière arête orientée tracée.

\newpage
\subsection{Méthodes associées au cycle orienté pour les algorithmes}


Pour l'implémentation d'un algorithme, les méthodes suivantes sont disponibles:
\begin{itemize}
\item {\bf void sendToNext (Message msg)} qui envoie un message {\it msg} au noeud suivant dans le cycle.
\item {\bf void receiveFromPrevious()} qui indique au noeud de recevoir des messages en provenance du noeud précédent; il est ainsi possible de demander à un noeud de ne recevoir que ce type de messages tout en ignorant ceux des autres voisins.
\item {\bf int nextDoor()} retourne l'identité du noeud suivant.
\item {\bf int previousDoor()} retourne l'identité du noeud précédant.\\
\end{itemize}
{\bf Remarque importante}: Ces méthodes peuvent être employées sans risque pour des sommets qui n'appartiennent pas au cycle. Autrement dit, si le cycle n'est pas recouvrant, il n'est pas nécessaire de disposer de deux algorithmes dont un s'appliquerait exclusivement aux noeuds hors du cycle.\\\\
Car pour un noeud n'appartenant pas au cycle: 
\begin{itemize}
\item {\bf sendToNext (Message)} et {\bf receiveFromPrevious()} seront tout simplement ignorées sans qu'une erreur ne se produise.
\item {\bf int nextDoor()} et {\bf int previousDoor()} retourneront {\bf NULL}.
\end{itemize}

