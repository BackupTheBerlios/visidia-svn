\chapter*{Introduction}
%          * Décrire la problématique et la motivation
%          * Placer le système dans son contexte
%          * Donner son rôle dans l'organisation qui l'englobe 


\subsection*{Contexte d'utilisation}

L'algorithmique distribuée devient de nos jours de plus en plus
importante aux vues des utilisations possibles sur les réseaux et
autres systèmes distribués.

Cependant,  les   applications  distribuées  qui   en  découlent  sont
difficiles à implanter, tester  et expérimenter.  En effet, celles-ci,
en  plus  des  problèmes  des  applications  classiques  centralisées,
doivent  gérer  des problèmes  de communication  entre processus,  de
concurrence  et de  conflits  de  ressources.  C'est  dans  le but  de
faciliter la tâche à un développeur d'algorithmes  distribués que des
chercheurs  du  LaBRI  ont   créé  \visidia.

Ce logiciel est un atelier proposant des outils
de simulation  et  de visualisation au travers  d'animations 
graphiques en temps réel et proposant l'exécution d'un algorithme distribué sur
un graphe  donné.  Cet algorithme peut être  choisi dans une liste,
algorithme développé par  l'utilisateur, ou encore  dessiné grâce à des
règles de réécriture.

L'application  va  donc  constituer  à  terme un  outil permettant la 
validation pratique de résultats théoriques sur un environnement
distribué.


\subsubsection*{Définition d'un réseau}

L'algorithmique distribuée s'intéresse à la réalisation d'un
calcul distribué sur un ensemble de processeurs reliés par des
canaux de communication. 
Cette structure est modélisée par un graphe, dont les sommets
représentent les processeurs et les arêtes les canaux de
communication. Dans la suite, on ne fera pas de distinction entre
processeurs sommets ou n\oe uds.

\subsection*{Notions d'algorithmique distribuée}

Il existe plusieurs modèles permettant de décrire des algorithmes
distribués. Parmi eux, deux ont été développés dans \visidia : la
communication par échange de message et par agent.

\subsubsection*{Modèle avec envoi de messages}

Dans ce modèle, chaque n\oe ud représente un système ou un processeur. Sur chaque
n\oe ud est exécuté un algorithme disposant de certaines primitives qui lui permettent de
communiquer à l'aide de messages avec ses n\oe uds voisins.
Les n\oe uds sont reliés entre eux par des canaux de communication
(les arêtes du graphe) par lesquels transitent les messages. 

\subsubsection*{Modèle avec agent mobile}

Ce second modèle, plus récent que le précédent, considère que le système
représenté par un n\oe ud ne dispose pas d'unité de calcul mais seulement d'une
mémoire. Les n\oe uds sont ainsi dépourvus d'algorithme et ne peuvent donc pas
communiquer directement entre eux.

L'exécution des algorithmes se fait par des agents. Ces entités possèdent une
capacité de calcul ainsi qu'une mémoire. Un agent se déplace dans le graphe
et exécute un algorithme qui lui est associé.

Dans la suite, nous parlerons de mémoire d'un agent et d'un sommet.
La mémoire d'un agent contient les variables qu'il a déclarées tandis que
la mémoire d'un sommet fait référence à son \texttt{whiteboard} et aux valeurs
de ses ports.
Le \texttt{whiteboard} est une structure qui contient des variables tandis que
chaque port dispose d'une valeur en mémoire qui lui est associée.



\subsection*{L'existant}

\visidia implémente aujourd'hui les deux modèles de communication présentés
précédemment. La gestion des agents a été ajoutée l'année dernière. Seule cette
partie concernera le projet, la partie sur la communication par message ne sera
pas étudiée.

L'application \visidia a été réalisée en respectant une séparation en
trois parties, interface graphique, simulateur et agents (ou
algorithmes pour la version sans agent).
L'interface graphique permet à l'utilisateur d'intéragir avec le
programme et de consulter l'avancement d'une exécution d'agent sur un
graphe. Elle est synchronisée avec le simulateur pour éviter toute
incohérence. Elle fournit quelques statistiques de base sur
l'exécution. Le simulateur coordonne les opérations. C'est le c\oe ur
de \visidia. Enfin, les agents permettent de réaliser des
opérations sur le graphe.

\begin{figure}[h!t]
  \centering
  \includegraphics[width=6cm]{img/structureVisidia.eps}
  \caption{Structuration de \visidia}
  \label{fig:implantation-communication}
\end{figure}

Une bibliothèque de primitives de  base (\emph{API}) est mise à
disposition de l'utilisateur afin qu'il puisse réaliser ses propres
algorithmes à base d'agent. 


\subsection*{Motivations et but}

La version avec agent mobile de \visidia offre aujourd'hui suffisamment de
fonctionnalités pour simuler les algorithmes à base d'agent mobile.

Néanmoins, contrairement à la partie de \visidia avec communication par message
qui possède un grand nombre d'algorithmes développés, la partie avec agent mobile
se limite à quelques-uns. L'implémentation des algorithmes dans \visidia n'est
pas aisée et la procédure est peu documentée :
l'implémentation d'algorithmes est nécessaire pour tester
l'application et ses nouvelles fonctionnalités. Enfin, une
documentation d'implémentation des algorithmes sera utile dans
l'avenir pour le client.

Le cas des statistiques sur l'exécution des algorithmes est un point particulièrement
important pour le client. En effet, \visidia est un outil qui lui permet de
confronter résultats théoriques et expérimentaux. Ce sont les statistiques qui
permettent cette comparaison et celles-ci sont actuellement très limitées.

Un autre besoin du client est de pouvoir agir sur le graphe au cours de
l'exécution d'un algorithme. En effet, en algorithmique distribuée on
s'intéresse aux conséquences d'une évolution de la topologie du réseau, de
l'altération des mémoires d'un n\oe ud du réseau ou d'un agent, voire du crash
accidentel d'un de ces derniers.
