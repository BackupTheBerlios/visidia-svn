 \chapter{Besoins fonctionnels et non fonctionnels}
%          * Services offerts aux utilisateurs
%          * Collaborations et séquences (diagrammes UML)
%          * Contraintes : sur le produit (usabilité, efficacité, fiabilité), sur le processus de développement (normes), ou externes (légales, coûts) 


\section{Besoins fonctionnels}

\input{BF_agirSommet}

\input{BF_agir_graphe1}

\input{BF_agir_agents}





\section{Priorités d'implémentation}

\input{priorite_besoins}





\section{Besoins non fonctionnels}

\subsection{Implémentation d'algorithmes existants}

Nous proposons ci-dessous une brève description de trois algorithmes à implémenter. Leur description formelle est fournie en anglais par le LaBRI.

\begin{itemize}
  \item RDV : savoir au bout de combien de temps deux agents vont se rencontrer
  \item GATHERING : On traite k agents où k est supérieure à 2. Si deux agents se rencontrent, ils fusionnent. Fusionner c'est choisir aléatoirement un agent qui va annexer la mémoire des autres agents à sa propre mémoire. Il est à remarquer qu'une rencontre ne peut pas se faire sur une arête : la rencontre n'a un sens que sur un sommet.
  \item CALCUL DISTRIBUÉ D'UN ARBRE COUVRANT : on lance en même temps plusieurs agents (ces derniers possèdent des identificateurs ID). Chaque agent fait son propre calcul. Si un agent rencontre une région calculée par un autre agent d'ID plus faible, le premier annexe la région du 2ème, ceci en la récupérant grâce à un clone du 1er qui va effectuer un parcours en profondeur sur la région du 2e.
\end{itemize}


\subsection{Structuration de l'application}

L'application \visidia a été développée en respectant une séparation en trois modules : l'interface graphique,
le simulateur et les agents (ou algorithmes pour la version sans agent). Cette séparation doit être conservée
par tous les ajouts et modifications que nous aurons à réaliser.


\subsection{Standard de codage}

Nous utiliserons par ordre de priorité les standards de codage établis dans le code pré-existant puis les standards de codage definis par le langage Java. 


\subsection{License}
L'ensemble de notre  programme sera sous licence GNU  GPL (GNU General
Public License)  version 2. Une  version de la licence
sera disponible en français et en anglais dans le  code source.


\subsection{Langue}

L'interface de \visidia a été réalisée en anglais. Il est donc impératif de continuer
à employer cette langue lors de sa modification. Même chose pour la documentation des
sources.


\subsection{Documentation}

La documentation du code source de l'application sera réalisée à l'aide de l'outil \texttt{Javadoc}
et cela de manière à ce que le code produit puisse être compris aisément.





%% \subsection{Mise en pause du programme}

%% Celle-ci est déjà implémentée et fonctionnelle. Une vérification approfondie de son
%% fonctionnement devra etre effectuée.

%% Un objectif secondaire serait de mettre en pause l'exécution des agents de manière
%% automatique lors de la modification d'un agent ou d'un sommet.

%% \subsection{Modification d'un sommet}

%% Il est nécessaire de pouvoir modifier un sommet au cours de l'exécution du programme.
%% Plusieurs stratégies peuvent etre mises en ½uvre pour deconnecter un noeud : déconnexion choisie, panne
%% ou suppression d'un sommet pendant l'exécution.

%% \subsection{Partie Simulation}

%% * De petites modifications sont a apportees a l'IHM pour ameliorer l'ergonomie du
%% logiciel.\\

%% * Possibilité d'avoir une conservation des traces (agents, mémoire)\\


%% \subsection{Structure de données}

%% Actuellement les meme structures sont utilisees pour l'edition et la simulation
%% des graphes. Or pour implémenter les fonctionnalités de modification en cours 
%% d'execution, des modification seront peut être à envisager. Envisager de modifier la structure
%% pour la cohérence des algorithmes avec les agents peut prendre un temps
%% considérable : il faut encore réfléchir avant d'envisager de modifier
%% complètement l'implémentation actuelle.

%% \subsection{Règle de réécriture des agents}

%% Pour « marquer » une arête : bloquer les sommets, aller-retour de l'agent entre
%% les sommets
%% Possibilité : ajouter dans le tableau blanc des sommets les ports marqués

%% Pour l'instant, seul les rencontres de types « rendez-vous » sont implémentées, il est
%% envisageable d'implémenter au moins celles de types « LC1 ».

%% \subsection{Algorithme de placement des agents}

%% Les algorithmes de répartition des agents développés ne separent pas la méthode de
%% répartition des agents du type d'agent ajouté. Il faudrait envisager de dissocier ces
%% deux aspects.

%% \subsection{Statistiques}

%% Quelques statistiques sont actuellement fournies sur les algorithmes à base d'agent.
%% Cependant les informations fournies sont insuffisantes et relatives au graphe et non a
%% chaque agent et noeud. Il est donc necessaire d'affiner ces informations et les rendres
%% disponibles tout au long de l'execution des algorithmes.\\

%% Une option de \visidia permet de compter le nombre approximatif de thread utilises durant la simulation. Un objectif
%% secondaire du projet pourrait etre de preciser ce nombre.



%% \subsection{Limitation des besoins}

%% \subsubsection{Sauvegarde du graphe}

%% La sauvegarde du graphe est possible avant d'entrer dans la partie simulation. Bien que l'utilisateur
%% pourra desormais modifier le graphe depuis cette derniere partie, il ne lui sera pas possible de sauvegarder
%% ses modifications.

%% \subsubsection{Action sur le graphe en temps reel}

%% Les modifications qui pourront etre apportees au graphe pendant la simulation pourront etre faites
%% seulement apres la mise en pause de l'execution. Cette mise en pause puis la remise en route pourra 
%% etre declenche de maniere automatique par le systeme pour simuler une modification en temps reel.

