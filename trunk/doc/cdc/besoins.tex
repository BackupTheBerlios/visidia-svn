 \chapter{Besoins fonctionnels et non fonctionnels}
%          * Services offerts aux utilisateurs
%          * Collaborations et séquences (diagrammes UML)
%          * Contraintes : sur le produit (usabilité, efficacité, fiabilité), sur le processus de développement (normes), ou externes (légales, coûts) 


\section{Besoins fonctionnels}

\subsection{Mise en pause du programme}

Celle-ci est déjà implémentée et fonctionnelle. Une vérification approfondie de son
fonctionnement devra etre effectuée.

Un objectif secondaire serait de mettre en pause l'exécution des agents de manière
automatique lors de la modification d'un agent ou d'un sommet.

\subsection{Modification d'un sommet}

Il est nécessaire de pouvoir modifier un sommet au cours de l'exécution du programme.
Plusieurs stratégies peuvent etre mises en ½uvre pour deconnecter un noeud : déconnexion choisie, panne
ou suppression d'un sommet pendant l'exécution.

\subsection{Partie Simulation}

* De petites modifications sont a apportees a l'IHM pour ameliorer l'ergonomie du
logiciel.\\

* Possibilité d'avoir une conservation des traces (agents, mémoire)\\


\subsection{Structure de données}

Actuellement les meme structures sont utilisees pour l'edition et la simulation
des graphes. Or pour implémenter les fonctionnalités de modification en cours 
d'execution, des modification seront peut être à envisager. Envisager de modifier la structure
pour la cohérence des algorithmes avec les agents peut prendre un temps
considérable : il faut encore réfléchir avant d'envisager de modifier
complètement l'implémentation actuelle.

\subsection{Règle de réécriture des agents}

Pour « marquer » une arête : bloquer les sommets, aller-retour de l'agent entre
les sommets
Possibilité : ajouter dans le tableau blanc des sommets les ports marqués

Pour l'instant, seul les rencontres de types « rendez-vous » sont implémentées, il est
envisageable d'implémenter au moins celles de types « LC1 ».

\subsection{Algorithme de placement des agents}

Les algorithmes de répartition des agents développés ne separent pas la méthode de
répartition des agents du type d'agent ajouté. Il faudrait envisager de dissocier ces
deux aspects.

\subsection{Statistiques}

Quelques statistiques sont actuellement fournies sur les algorithmes à base d'agent.
Cependant les informations fournies sont insuffisantes et relatives au graphe et non a
chaque agent et noeud. Il est donc necessaire d'affiner ces informations et les rendres
disponibles tout au long de l'execution des algorithmes.\\

Une option de \visidia permet de compter le nombre approximatif de thread utilises durant la simulation. Un objectif
secondaire du projet pourrait etre de preciser ce nombre.



\subsection{Limitation des besoins}

\subsubsection{Sauvegarde du graphe}

La sauvegarde du graphe est possible avant d'entrer dans la partie simulation. Bien que l'utilisateur
pourra desormais modifier le graphe depuis cette derniere partie, il ne lui sera pas possible de sauvegarder
ses modifications.

\subsubsection{Action sur le graphe en temps reel}

Les modifications qui pourront etre apportees au graphe pendant la simulation pourront etre faites
seulement apres la mise en pause de l'execution. Cette mise en pause puis la remise en route pourra 
etre declenche de maniere automatique par le systeme pour simuler une modification en temps reel.

\section{Besoins non fonctionnels}

\subsection{Les contraintes d'interface}
\visidia a été implémenté en langage Java, nous utiliserons donc le même langage pour poursuivre la suite de son développement.
Le choix d'un tel langage de programmation présentant notament l'avantage de la
portabilité du programme quel que soit le type de plateforme.

L'interface et les commentaires du code de l'application étant rédigé en anglais, nous continuerons à rédiger cela dans la même langue.


\subsection{Standard de codage}

Nous utiliserons par ordre de priorité les standards de codage établi dans le code pré-existant puis les standards de codage definis par le langage Java. 

\subsection{License}
L'ensemble de notre  programme sera sous licence GNU  GPL (GNU General
Public License)  version 2  ou supérieure. Une  version de  la licence
sera disponible en  français et en anglais dans le  code source, et un
rappel sera effectué à chaque en-tête de fichier. 


\subsection{Les contraintes de performance}
Les performances de \visidia ne sont pas un critère primordial sur ce projet.
Nous implémenterons donc nos algorithmes en essayant d'avoir les meilleurs résultats possibles mais pas forcément ceux étant optimaux.
De plus nous limitions l'utilisation du logiciel sur des graphes
relativement petits ou simples. Si un utilisateur souhaite effectuer
des statistiques sur des graphes plus complexes, il n'aura
probablement pas besoin d'avoir une visualisation graphique. 
