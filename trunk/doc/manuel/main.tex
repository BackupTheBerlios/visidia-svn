\documentclass{article}

\usepackage[pdftex,
  colorlinks=true,
  pdfstartview=FitV,
  linkcolor=blue,
  citecolor=blue,
  urlcolor=blue]{hyperref}
\usepackage{xspace}
\usepackage{geometry}
\geometry{a4paper}
\usepackage{indentfirst}
\usepackage[francais]{babel}
\usepackage[latin1]{inputenc}
\usepackage[dvips]{graphicx}

\newcommand{\visidia}{ViSiDiA\xspace}
\newcommand{\dossier}[1]{$#1$}
\newcommand{\classe}[1]{$#1$}
\newcommand{\methode}[1]{$#1$}

\title{Mode d'emploi pour \visidia et les agents mobiles}
\author{L'équipe PFA \visidia 2006}
\date{Mars 2006}

\begin{document}
\maketitle
\tableofcontents


% Simu Agent mobile
%   Ajouter 1 agent
%      Via API
%        - manu
%        - placeur
%      Via regles de reecriture
%   Edition WhiteBoards
%     WB Agent
%     WB Sommet
%       - def
%       - specif
%   Execution simulation
%     pulse stop pause
%   Statistiques
%       
% Programmation      
%   Agent
%   Agent Sync
%   Mover
%   Placeur
%   Stats

\section{Objet}

Ce  document  a pour  objet  d'être  un  aperçu sur  l'utilisation  de
\visidia avec  les agents mobiles.  Nous considérerons que  le lecteur
maîtrise déjà  \visidia et  que l'environnement de  développement Java
est déjà installé et configuré.\\

Dans  un premier  temps, nous  téléchargerons la  branche  de \visidia
concernant  les  agents   et  compilerons  l'ensemble.   Ensuite  nous
présenterons  l'API des agents  et détaillerons  la procédure  pour en
créer  de nouveaux.  Après  cela, nous  étudierons  comment créer  des
modules de déplacement pour que vos agents changent de sommet de façon
bien définie. Enfin, nous présenterons la technique qui vous permettra
de  programmer des algorithmes  de placement  initial d'agents  sur le
graphe. 



\section{Installer et lancer \visidia}

Il existe  deux techniques pour  récupérer \visidia doté de  la partie
agents mobiles.  Soit vous  utilisez une version supposée stable, soit
vous récupérez une version de développement. 


\subsection{Récupérer la version stable}

Pour   récupérer    la   version    stable,   allez   sur    le   site
\url{https://developer.berlios.de/projects/visidia/}. Au  milieu de la
page,  vous trouverez  une  section nommée  ``Dernières révisions  des
fichiers''. Cliquez  alors sur le lien téléchargement  et récupérez le
fichier le plus récent. Enfin,  décompressez le fichier à l'aide de la
commande :

\begin{verbatim}
$ tar xvfj lefichiertelecharge.tar.bz2
$
\end{verbatim}


\subsection{Récupérer la version en développement}

Pour disposer de la version  de développement, vous devez posséder SVN
qui   est  un   remplaçant   de   CVS  disponible   sur   le  site   :
\url{http://subversion.tigris.org/}.\\

Le gestionnaire de version SVN est compilé et disponible sous forme de
paquets près à l'emploi pour la majorité des distributions Linux. Sous
Windows,   TortoiseSVN   permet   de   travailler  sous   SVN   depuis
l'explorateur   de   fichiers.  Il   est   disponible   sur  le   site
\url{http://www.tortoisesvn.tigris.org/}.\\


Pour  télécharger la  version de  développement, utilisez  la commande
suivante :

\begin{verbatim}
$ svn checkout svn://svn.berlios.de/visidia/trunk/src visidia
$
\end{verbatim}

Cela va créer un répertoire \dossier{visidia} dans le dossier courant. 


\subsection{Compiler et lancer \visidia}

Pour compiler  \visidia, le  kit de développement  Java 5.0  doit être
installé et présent dans votre PATH.  Il est disponible sur le site de
SUN   \url{http://java.sun.com/j2se/1.5.0/download.jsp}.\\   Pour   le
vérifier :

\begin{verbatim}
$ javac -version
javac 1.5.0
$
\end{verbatim}

Placez-vous  dans  le  répertoire  \dossier{visidia} et  exécuter  les
commandes suivantes pour compiler puis pour lancer \visidia :

\begin{verbatim}
$ ./compile.sh
$ ./acompile.sh
$ ./visidia.sh
$
\end{verbatim}

La première  ligne compile \visidia  alors que la seconde  compile les
modules  comme les algorithmes,  les agents  etc.  La  troisième lance
\visidia. Suivant votre installation,  vous pourriez avoir de nombreux
messages d'avertissements concernant les accents. Ces messages ne sont
pas bloquants, vous pouvez les ignorer.\\

Si tout  c'est bien passé,  \visidia devrait être lancé.  Vous devriez
voir l'application comme sur la figure \ref{fig:visidia}.

\begin{figure}[ht]
  \centering
  \includegraphics[width=10cm]{visidia}
  \caption{Lancement de \visidia}
  \label{fig:visidia}
\end{figure}

\section{Utilisation de \visidia}

\subsection{Creation d'un graphe}

Une fois \visidia lancé, la fenêtre d'édition de graphe apparaît :

Le graphe se construit à l'aide du clic gauche de la souris. Les
graphes peuvent également être sauvegardé grâce aux commandes \textbf{Save}
ou \textbf{Save as...} du menu \textbf{File}.

Dans le menu Transformation :
\begin{itemize}
\item \textbf{Complete} permet de transformer le graphe courant en un graphe complet.
\item \textbf{Delete edges} permet d'effacer les arêtes du graphe.
\item \textbf{Change edges shape} permet de modifier la nature du graphe
  (orienté ou non orienté).
\item \textbf{Change vertices shape} permet de modifier la nature des
  sommets du graphe.
\item \textbf{Vertex renumbering} permet de renuméroter les sommets du
  graphs.
\end{itemize}

Une fois le graphe créé, il est possible de faire exécuter \visidia
selon trois mode :

\begin{itemize}
\item Simulation avec des messages en local : bouton \textbf{Simulation}
\item Simulation avec des messages avec répartition des noeuds du
  graphe sur plusieurs machines : bouton \textbf{Network Simulation}
\item Simulation avec des agents mobiles en local : bouton \textbf{Agents Simulation}
\end{itemize}

\subsection{Simulation avec des agents mobiles}

La première étape de la simulation avec des agents mobiles est le
placement d'agents sur des sommets. Pour effectuer ceci deux méthodes
peuvent être envisagées :
\begin{itemize}
\item Le placement manuel : Sélectionner un ou plusieurs sommets avec
  le clic droit de la souris (si besoin en maintenant la touche SHIFT
  en cas de sélection multiple).
\item Le placement automatique grâce au placeur : Lancer la commande
  \textbf{Place Agents...} du menu \textbf{Agents}. Cette technique de
  placement ne fonctionne qu'avec les algorithmes compilés avec l'API.
\end{itemize}

Ensuite, les agents peuvent être ajoutés aux sommets sélectionnés.

\subsubsection{Ajouter des agents écrits avec l'API}


Pour les agents écrits avec l'API, utilisez la commande \textbf{Add
  Agent...} du menu \textbf{Agent}. Sélectionnez ensuite le type
d'agent à ajouter en sélectionnant l'algorithme compilé dans la boite
de dialogue. Pour plus d'information sur l'écriture d'algorithmes à
l'aide de l'API, veuillez vous référez à la section \emph{Programmer
  des agents}.

\subsubsection{Ajouter des d'agents définis avec des règles de réécritures}

  \begin{itemize}
  \item Créer un nouveau jeux de règle de réécriture avec la commande utilisez la
    commande \textbf{New relabeling system} du menu \textbf{Rules}.
  \item Ouvrir un jeu de règle de réécriture précédemment sauvegardé
    avec la commande \textbf{Open rules...} du menu \textbf{Rules}.
  \end{itemize}
  


\section{Programmer des agents avec l'API}

% mini-plan de la section
% Programmation      
%   Agent
%   Agent Sync
%   Mover
%   Placeur
%   Stats

Dans cette section, nous commencerons par voir l'API de programmation
des agents puis la méthode à adopter pour en programmer de
nouveaux. Nous verons également comment programmer des algorithmes de
déplacement, avant de nous interreser à l'implantation de techniques de
placement initial d'agents. Et pour conclure nous verrons comment il
est possible de créer des statistiques persnnalisées.\\

Vous pouvez aussi vous baser sur des exemples déjà écrits ; vous en
trouverez un grand nombre dans les répertoires :
\begin{enumerate}
\item \dossier{sources/visidia/agents} pour les agents.
\item \dossier{sources/visidia/agents/agentsmover} pour les algorithmes de déplacement.
\item \dossier{sources/visidia/agents/agentchooser} pour le placement
  initial d'agents.
\item \dossier{sources/visidia/agents/agentreport} pour la creation de
  statistiques.
\end{enumerate}


\subsection{Description de l'API}
\label{sec:agent-api}

Toute la documentation a été  écrite à l'aide de Javadoc. Pour générer
des fichiers  HTML, placez vous  dans le dossier  \dossier{visidia} et
tapez la commande suivante :

\begin{verbatim}
$ ./agents-doc.sh
$
\end{verbatim}

Ceci  fait, ouvrez le  fichier \dossier{visidia/agents-doc/index.html}
avec un navigateur. 


\subsection{Ecrire ses propres agents}

Il existe deux types d'agents : les agents non-synchronisés et les
agents synchronisés.

Dans ces deux cas, vous devez créer respectivement une sous-classe de la classe
\classe{Agent} ou de la classe \classe{SynchronizedAgent} et la placer
dans le dossier \dossier{visidia/sources/visidia/agents}.  N'oubliez
pas de renseigner le package grâce à la ligne :

\begin{verbatim}
package visidia.agents;
\end{verbatim}

La programmation de l'agent se fait en implémentant la
méthode\methode{init()} et en utilisant les différentes possibilités
offertes par l'API.\\


\subsubsection{Cas d'un agent non-synchronisé}

\begin{verbatim}

  protected void init() {
      
    do {
      Integer nbPassages;

      try {
        nbPassages = (Integer) getVertexProperty("nbPassages");
      } catch (NoSuchElementException e) {
        nbPassages = 0;
      }

      nbPassages = new Integer(nbPassages.intValue() + 1);
      setVertexProperty("nbPassages", nbPassages);

      Random rand = new Random();

      moveToDoor(rand.nextInt(getArity()));
    } while (true);
  }
\end{verbatim}

L'objectif de cet agent est de compter le nombre de passage des agents
sur chaque sommet.  Pour mémoriser le nombre de passages sur chaque
sommet, nous avons utilisé le champs ``nbPassages'' du whiteboard du
sommet.

Pour ce faire, nous essayons dans un premier temps de récupérer le
nombre de passages de ce type d'agent sur le whiteboard du sommet
courant par le biais de la
\methode{getVertexProperty(``nbPassages'')}. Si ce champs n'a pas été
préalablement inscrit dans le whiteboard du sommet, l'appel à la
méthode \mehode{getVertexProperty(``nbPassages''}} va déclencher une
exception de type \emph{NoSuchElementException}. Si tel est le cas,
nous considérons qu'il s'agit de notre premier passage. Ceci est
effectué dans le \emph{catch}.

Ensuite, nous incrémentons le nombre de passages de un, puis l'agent
réécrit la nouvelle valeur dans le champs ``nbPassages'' du sommet
courant graçe à la méthode \methode{setVertexProperty(``nbPassages''}.

\subsubsection{Cas d'un agent synchronisé}

\begin{verbatim}
public class BasicSynchronizedAgent1 extends SynchronizedAgent {

    protected void init() {

        for(int i=0; i<10; ++i) {
          Random rand = new Random();
	 
          nextPulse();
          moveToDoor(rand.nextInt(getArity()));
	}
    }
}
\end{verbatim}

Cet agent se déplace aléatoirement à travers le graphe et meurt au
bout de 10 déplacements. Veuillez noter l'appel à la méthode
\methode{nextPulse()} qui permet de synchroniser les agents : chaque
agent synchronisé sera bloqué à l'appel de cette méthode jusqu'à ce
que le dernier agent synchronisé fasse à son tour appel à cette
méthode. Un rendez-vous, c'est à dire une rencontre entre agents, peut
alors être organisé.

Le rendez-vous est réalisé en implémentant la méthode
\methode{planning(SynchronizedAgent)} qui sera appelé à chaque fois
qu'un rendez-vous à lieu sur un sommet.


\section{Développer des algorithmes de déplacement}

La méthode de création d'algorithmes de déplacement est presque
identique à la méthode de création d'agents. Pour cela il suffit de
sous classer la classe \classe{AgentMover} et implanter la méthode
\methode{findNextDoor()}. De plus vous disposez de toutes les
informations nécessaires sur l'agent grâce à la méthode
\methode{agent()}.  Les algorithmes que vous écrirez devront se
trouver dans le paquet \dossier{visidia.agents.agentsmover}.



Voici le code d'un algorithme d'un déplacement aléatoire :

\begin{itemize}
public class RandomAgentMover extends AgentMover {
    
    public RandomAgentMover(Agent ag) {
        super(ag);
    }

    protected int findNextDoor() {
        Random rand = new Random();

        return rand.nextInt(agent().getArity());
    }
}
\end{itemize}

Pour utiliser cet algorithme de déplacement pour un agent, utilisez le
méthode \methode{setAgentMover(``RandomAgentMover'')} . Le nom passé
en paramètre doit correspondre exactement au nom de la classe (casse
comprise). Le déplacamant ne se fera plus avec
\methode{moveToDoor(int)} mais avec \methode{move()}

Voici comment nous pouvons réécrire notre BasicSynchronizedAgent1 :

\begin{itemize}
public class BasicSynchronizedAgent1 extends SynchronizedAgent {

  protected void init() {
    setAgentMover("RandomAgentMover");
    
    for(int i=0; i<10; ++i) {
      
      nextPulse();
      move();
    }
}
\end{itemize}

Pour plus d'informations, référez vous à la javadoc comme indiqué en
\ref{sec:agent-api} et lisez particulièrement la documentation de la
classe \classe{AgentMover}.

D'autre exemples d'algorithmes de placement sont disponibles dans le
package \dossier{visidia.agents.agentsmover}

\section{Implanter des techniques de placement initial d'agents}

Comme pour les algorithmes de déplacement des agents sur le graphe, la
programmation  de nouveaux  algorithmes de  placement d'agent  se fait
simplement   et  la  lecture   de  la   documentation  de   la  classe
\classe{AgentChooser}  ainsi  que  le  parcours des  exemples  devrait
suffire.\\

Vos algorithmes  de placement d'agents devront être  implantés dans le
paquet  \dossier{visidia.agents.agentchooser},  devront surcharger  la
méthode  \methode{chooseForVertex(Integer)}   et  devront  appeler  la
méthode \methode{addAgent(Integer, String)} pour ajouter des agents.



\section{Création de statistiques personnalisées}

La création de statistiques peut etre entièrement personnalisée.  Pour
cela il vous faudra écrire une classe héritant de
\classe{AbstractStatReport} dans laquelle vous devrez redéfinir la
méthode \methode{getStats()} qui retournera l'ensemble des
statistiques.  Ces statistiques devront faire partie du package
\dossier{visidia.agents.agentreport}

Voici un exemple calculant le nombre de déplacements moyen par type
d'agent :

\begin{verbatim}
public class AverageMoveReport extends AbstractStatReport {
    /**
     * Used to store the number of agents of type given by Class. Keys
     * represent the class of agents (BasicAgent, SpanningTree...) and
     * values represent the number of agents for that class.
     */
    private Hashtable<Class, Long> agentsByClass;

    /**
     * Will  store the  report  information. Everything  that will  be
     * displayed on the report will be in that variable.
     */
    private Bag stats;

    /**
     * Used to fill the <code>agentsByClass</code> instance variable.
     */
    private void countAgents() {
	Set keys;
	agentsByClass = new Hashtable(10);

	/**
	 * Keys is  a Set  containing all the  events reported  by the
	 * simulator.
	 */
	keys = getBag().keySet();

	/**
	 * For each events
	 */
	for(Object key: keys) {
	    if (key instanceof AgentCreationStat) // if    it   is   a
						  // creation event
		agentsByClass.put(((AgentCreationStat)key).getAgentClass(),
				  new Long(getBag().getOccurrencesOf(key)));
	}
    }

    /**
     * Count the moves by agent type.
     */
    private void computeStats() {
	Set keys;

	stats = new Bag();

	countAgents();

	/**
	 * Keys is a set containing all the events.
	 */
	keys = getBag().keySet();

	for(Object key: keys) {
	    float movesByAgent;

	    if (key instanceof MoveStat) { // if it is a move event
		Class agClass = ((MoveStat)key).getAgentClass();
		long agentsForClass = agentsByClass.get(agClass).longValue();
		long movesForClass = getBag().getOccurrencesOf(key);

		stats.add("Average moves by agent (" 
			  + agClass.getSimpleName() + ")",
			  new Long(movesForClass / agentsForClass));
	    }
	}
    }

    /**
     * Calculate the  number of  moves by agent  type and  returns the
     * results that will be displayed.
     */
    public Bag getStats() {
        computeStats();
        return stats;
    }

\end{verbatim}


\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-1
%%% TeX-PDF-mode: t
%%% End: 
