Dans cette  partie, nous  allons nous attacher  à développer  de façon
détaillée l'implantation de notre  module au sein du logiciel \visidia
existant.\\

Le projet s'est subdivisé en deux parties essentielles :
\begin{itemize}
\item le développement de l'API et de la simulation.
\item  l'intégration  des  nouvelles  fonctionnalités  dans  la  partie
graphique de \visidia.
\end{itemize}


\section{Agents}
Cette section  concerne le développement  des agents et donc  de l'API
fournie aux clients. Le description  de cette API ayant déjà été faite
dans la  partie précédente  nous ne nous  attarderons pas  dessus ici.
Elle est  entièrement définie et  implantée dans la  classe Agent.java
qui se trouve dans  le package visidia.simulation.agents. 

Les méthodes de cette classe sont basées sur des appels au méthodes du
simulateur qui correspondent.  En effet, comme c'est le simulateur qui
fait le lien  entre l'interface graphique et les agents  il est tout a
fait normal qu'il ait la charge des actions effectuées par les agents.

En plus  du simulateur duquel il  dépend et de son  identité, un agent
contient une  structure de donnée  de type WhiteBoard définie  dans le
package visidia.tools.agents  et qui permet  à l'agent de  stocker des
informations durant son exécution.  Un WhiteBoard s'utilise de la même
manière qu'une table de  hachage, la différence étant qu'un WhiteBoard
permet un accès  a des valeurs par défaut. etc  ...  Nous avons choisi
de travailler avec  des tables de hachage pour  permettre de gagner de
l'espace  mémoire. En  effet, l'utilisation  d'une autre  structure de
données aurait amener a réserver  de l'espace pour un nombre prédéfini
de champs au départ  et de réallouer de la mémoire au  fur et à mesure
de l'exécution. Une table de  hachage permet d'allouer l'espace au fur
et à mesure et si aucun champs n'a été ajouter on ne .... 

- autre structure de données utilisées  par les agents : agent mover :
  une  classe  qui  permet   de  déplacer  des  agents.  définie  dans
  visidia.simulation.agents ...

- développer une partie sur agent chooser

- reprendre le  digramme de  classe de Damien  en ce qui  concerne les
  agents.

\section{Simulateur}

- axe du module 
_ fait appel à lui pour tous les actions des agents
- relation interface graphique ( accès au agents et aux sommets)
- permet la gestion des agents, faire des stats etc ...
- décrire les structure de données qui y sont + justification
- synchronisation
- meeting

\section{GUI}

- partie la  plus importante du point  de vue de  l'utilisateur + pkoi
- décrire les principales  choses qu'on a ajouté en  relation avec les
  agents, les  sommets, le simulateur etc ...   
- implantation  de thread  java qui  permette le  rafraîchissement des
  fenêtres ...




%% Local Variables: 
%% mode: latex
%% TeX-master: t
%% TeX-PDF-mode: t
%% coding: latin-1
%% End: