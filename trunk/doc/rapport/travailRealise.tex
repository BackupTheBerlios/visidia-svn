\section{Ajout de fonctionnalités}

\subsection{Modification du graphe en cours d'exécution}

\subsubsection{Structure du graphe}

\visidia respecte une séparation stricte entre la partie affichage et la
partie simulation. Ainsi, deux type de graphes sont manipulés : un graphe visuel et un
autre pour la simulation.\\

Nous avons du dans un premier temps déterminer si les deux structures de graphes
étaient les mêmes, héritaient l'une de l'autre ou étaient différentes. Après une 
analyse plus poussée du code, nous avons découvert que les deux
structures étaient totalement dissociées et indépendantes l'une de l'autre.\\

Pour la partie simulation, le répertoire \textit{graph} contient toutes les classes
de l'architecture du graphe.
\begin{figure}[H]
  \centering
  \includegraphics[width=16cm]{images/SimpleGraph.png}
  \caption{Architecture du graphe du Simulateur}
\end{figure}

La classe \textit{SimpleGraph} contient l'architecture de ce graphe. On manipule
des \textit{Hashtable} pour stocker les arêtes et les sommets du graphe.\\

Pour la partie affichage, le répertoire \textit{gui.presentation} contient les
classes implémentant la structure du graphe visuel.
\begin{figure}[H]
  \centering
  \includegraphics[width=16cm]{images/VueGrapheSimplifiee.png}
  \caption{Architecture du graphe du Simulateur}
\end{figure}

La classe principale pour manipuler ce graphe est la classe \textit{VueGraphe}.


\subsubsection{Choix de développement}

Lors de la conception initiale de \visidia, il n'a pas été prévu que le graphe
visuel puisse évoluer au cours de la simulation.
En effet, aucune intéraction entre les deux graphes n'a été envisagée hormis, la
conversion d'un graphe visuel en un graphe de simulation par l'intermédiaire de
la classe \textit{Convertisseur} et de sa méthode \textit{convert()}.\\

En effet, le graphe visuel dessiné dans l'application principale
est converti en un graphe simulation au moment du passage vers
l'application \textit{simulation avec agents}. 
Après cette manipulation le graphe visuel étant présumé statique, aucune méthode
agissant sur le graphe dessiné ne répercutait les modifications sur le graphe de
simulation et vice versa.\\

Une solution possible à laquelle nous avions pensé, et qui permettait de
réutiliser ce qui avait été développé jusqu'à présent, était de
convertir le graphe visuel vers un graphe simulation à chaque fois que l'on
modifiait le graphe visuel. 
Nous n'avons cependant pas choisi d'implémenter cette méthode pour des raisons
évidentes de performance : la génération d'un nouveau graphe de simulation à
chaque ajout ou suppression d'arête ou sommet peut s'avérer très coûteuse,
surtout avec un graphe de grande taille. \\

Ainsi nous avons préféré pour chaque modification possible sur le graphe visuel, 
d'implémenter une méthode permettant de répercuter les effets sur le graphe de simulation.

\subsubsection{Ajout de sommets et d'arêtes}

L'ajout de sommets et d'arêtes sur le graphe visuel avait déjà été implémenté
pour la fenêtre principale de \visidia. Nous avons donc
récupéré ce code pour l'adapter à l'application de
simulation avec agents.\\

Nous avons ensuite implémenté une méthode \textit{addVertex()} et \textit{addEdge()} pour la
classe \textit{AgentSimulationWindow} qui pour
chaque sommet, respectivement chaque arête, que l'on souhaite ajouter au graphe
visuel, effectue l'opération et répercute la modification sur le graphe
simulation.

\subsubsection{Suppression de sommets et d'arêtes}

La suppression de sommet et d'arête a été plus délicate à gérer que l'ajout
puisqu'au moment où l'on souhaite retirer une arête ou un sommet, il est
possible qu'un agent soit sur l'élément considéré. Il faut donc pouvoir détecter
la présence d'un ou plusieurs agents sur un objet donné, et ensuite pouvoir le
ou les détruire en même temps que la suppression du sommet ou de l'arête.\\

Nous avons donc implémenté les méthodes \textit{removeVertex()} et \textit{removeEdge()} pour la
classe \textit{AgentSimulationWindow} qui pour
chaque sommet, respectivement chaque arête, que l'on souhaite supprimer du graphe
visuel, effectue l'opération et répercute la modification sur le graphe
simulation. 

Nous avons également ajouté à la classe \textit{AgentSimulator}, les méthodes
\textit{deleteVertex()} et \textit{deleteEdge()} qui réalise la suppression du simulateur d'un
sommet, respectivement d'une arête, tout en gérant le cas où un agent serait
présent en le supprimant.


\subsection{Ajout et suppression d'agent en cours d'exécution}

\subsubsection{Ajout d'agents en cours d'exécution}
L'ajout d'agents sur le graphe avait déjà été implémenté avant la simulation. Nous avons donc récupéré le code existant pour l'adapter à la simulation en cours d'exécution.\\


Après sélection d'un sommet, l'utilisateur utilise le menu
d'ajout d'agents. A ce moment, l'identificateur du sommet est
récupéré, et le nouvel agent est ajouté à l'ensemble
des agents avec la méthode \textit{addAgents()}. Une méthode
\textit{createAgentDuringExecution()} a été créée dans le
simulateur afin de créer effectivement l'agent sur le sommet
sélectionné et de lancer un \textit{thread} pour l'agent
nouvellement ajouté. 


\subsubsection{Suppression d'agents en cours d'exécution}
Un bouton a été ajouté dans la fenêtre de simulation afin
de permettre la suppression d'agents en cours d'exécution. L'ensemble des agents en
cours d'exécution est récupéré et l'utilisateur
sélectionne ensuite le nom de l'agent qu'il souhaite supprimer :
cette action fait alors appel à une méthode \textit{killAgent()}
qui a été créée dans le simulateur. En effet, les
fonctions de bases déjà présentes dans l'application \visidia
ne permettaient pas de tuer proprement un agent, sans que celui-ci
termine son déplacement jusqu'au prochain sommet si par exemple
l'agent était tué alors qu'il se déplaçait sur une
arête.\\


La méthode implémentée ci-dessus supprime le \textit{thread}
associé à l'agent et enlève ce dernier de la table de hachage
des agents. Enfin, afin que ces modifications soient prises en compte
dans la fenêtre de simulation, l'agent est également supprimé
graphiquement grâce à l'envoi d'un évènement à l'interface graphique.



\subsection{Modification des mémoires}

Le but de la modification de la mémoire des agents et des sommets est 
de simuler des erreurs. Donc, grâce à cette fonctionnalité, l'utilisateur 
peut modifier les valeurs des variables qui peuvent influencer le déroulement
des algorithmes. Ceci suppose qu'il a déjà stocké ces variables dans 
le whiteboard du sommet ou de l'agent. Le whiteboard d'un sommet regroupe la
mémoire du sommet et l'état de ses ports et, celui d'un agent comporte seulement
la mémoire de ce dernier. La mémoire d'un agent ou d'un sommet correspond à
l'ensembles des variables utilisés pour l'execution d'un algorithme.

\subsubsection{Modification de la mémoire des sommets}

En effet, les variables dont la modification des valeurs peut corrompre 
l'exécution des algorithmes varient suivant ces derniers. Cependant, 
il existe des variables qui peuvent engendrer des erreurs et ce quel que 
soit l'algorithme : leur modification peut affecter le déroulement de tous 
les algorithmes. Ces variables sont le booléen \textit{Visualisation} 
et la chaîne \textit{label} La première indique qu'un sommet est éteint quand 
elle est à \textit{false} et allumé si elle est à \textit{true}. La seconde variable 
indique la couleur du sommet. Ces deux variables sont par défaut stockées 
dans la mémoire des sommets.\\

 Si l'utilisateur souhaite pouvoir modifier 
d'autres variables pour simuler des erreurs, il n'a qu'à stocker ces variables
dans le \textit{whiteboard} en appelant les méthodes adéquates de la classe 
\textit{SimpleGraphVertex}, à savoir \textit{setProperty} et \textit{ getProperty()}.
Cette fonctionnalité de la modification de la mémoire a été implémentée de manière 
que toute modification de ces variables à travers la fenêtre de dialogue soit 
prise en compte et se répercute sur le déroulement de l'algorithme.
 
\subsubsection{Modification des mémoires des agents}

Dans le cas des agents, il n'y a pas de variables communes à tous les algorithmes.
L'utilisateur est alors invité à ajouter les variables de son choix dans le \textit{whiteboard}.
Bien évidemment, comme pour la mémoire des sommets, leur modification à travers la fenêtre 
de dialogue sera prise en compte et se répercutera sur le déroulement de l'algorithme.\\

Dans la version des algorithmes que nous avons reprise, les variables utilisées par
l'agent sont déclarées en tant que variables locales de la méthode \textit{init()}. 
Avec cette implémentation, simuler des erreurs en modifiant 
les valeurs de ces variables n'est pas possible. Pour remédier à ce problème,
nous avons donc envisagé deux solutions possibles :\\

\begin{itemize}

\item Pour chaque algorithme, stocker et initialiser ces variables dans 
le \textit{whiteboard}. À chaque fois qu'elles sont utilisées, on doit les mettre 
à jour en reprenant la valeur la plus récente à partir du \textit{whiteboard}. 
Ceci permet de prendre en compte les modifications "manuelles" apportées par
l'utilisateur et donc de simuler des erreurs. L'inconvénient de cette solution 
est qu'avant chaque instruction manipulant ces variables nous sommes 
obligés d'ajouter une instruction de mise à jour.\\


\item Utiliser une méthode \textit{initWhiteBoard()} qu'on implémente dans chaque
nouvelle classe définissant un nouvel agent. Son implémentation consiste en
le stockage et l'initialisation des variables que l'utilisateur souhaite modifier. 
Cette méthode ne peut pas être une méthode abstraite de la classe \textit{Agent} 
car sinon cela imposera que cette méthode soit implémentée dans toutes 
les sous-classes, ce qui entraînera des modifications considérables du code
des algorithmes : mettre toutes ces variables qui sont locales en tant qu'attribut
de l'agent en question et, par conséquent, modifier toutes les instructions les manipulant.
Cela dépendra en plus des choix de l'utilisateur notamment du choix des variables
qu'il souhaite modifier, ces variables variant suivant les algorithmes et suivant ses besoins. \\

\end{itemize}

Pour garantir une compatibilité ascendante du code, la première solution a été retenue 
pour les algorithmes déjà implémentés alors que pour les algorithmes que nous avons
codés, nous avons retenu la deuxième solution qui nous semble la plus pertinente. 


\subsection{Extinction et allumage des sommets}

Cette fonctionnalité permet à l'utilisateur de mettre à l'écart un sommet
sans le supprimer du graphe : l'exécution des algorithmes se fait comme si le sommet
n'existait pas. Pour indiquer qu'un sommet est éteint, on le colorie en gris
et on lui met l'étiquette \textit{Switch Off}. Bien évidemment,
une fonctionnalité  a été implémentée pour ré-allumer le sommet. Quand ce
dernier est de nouveau allumé, il reprend la couleur et l'étiquette qu'il avait
avant son extinction.\\

Cependant, l'extinction d'un sommet nécessite le plus souvent des traitements 
spéciaux pour les agents :

\begin{itemize}
\item Si un agent arrive sur un sommet qu'on vient d'éteindre, 
il repart d'où il vient sans exécuter aucun traitement sur le sommet éteint.\\ 

\item Si l'agent arrive sur un sommet et qu'entre temps ce sommet a été isolé du graphe 
en éteignant tous ses voisins, l'agent reste sur le sommet et
attend jusqu'à ce qu'au moins un de ses voisins soit ré-allumé pour
qu'il puisse quitter le sommet.\\

\item Si l'agent est sur une arête dont les deux sommets sont éteints, l'agent
s'endort dans le sommet auquel il arrive. Il ne se réveille et ne reprend
l'exécution de l'algorithme que si on allume le sommet dans lequel il s'endort
et que ce dernier ait au moins un voisin allumé vers lequel il peut diriger.\\ 

\end{itemize}

Un besoin important du client était de conserver une rétrocompatibilité de
visidia avec ses agents. Nous avons donc inclu ces traitements de manière
transparente au sein de la méthode move() de la classe Agent, appelée durant
l'exécution des agents.\\

Pour permettre à l'utilisateur de choisir ses propres traitements, nous avons
implémenté pour chaque cas particulier, une méthode dans la classe Agent avec un
traitement par défaut. Chaque méthode pouvant être surchargée dans la définition
de l'agent afin de spécifier un comportement particulier.
Les méthodes \textit {processingAgentWhenSwitchingOff()} et 
\textit{processingAgentIsolated()}, qui définissent respectivement le comportement de l'agent
 en cas d'extinction d'un sommet ou d'arrivée sur un sommet isolé, peuvent donc
 être surchargées. 



\subsection{Calcul des statistiques en temps réel}
Afin de disposer de statistiques en temps réel, nous avons
ajouté une méthode \textit{makeStatOnMove()} dans le simulateur
qui est appelée à chaque déplacement d'un agent. La classe
utilise la classe de statistiques, déjà existante, nommée
\textit{Bag} à laquelle on a ajouté des fonctions de base de
calcul de minimum, de maximum et de remplacement.\\


Afin d'avoir des statistiques sur chaque agent et plus seulement sur
chaque classe d'agent, des modifications ont été apportées
à la classe abstraite \textit{AbstractStats}.\\

C'est dans la nouvelle méthode \textit{makeStatOnMove()} du
simulateur qu'ont été implémentées les nouvelles
statistiques sur les agents et classes d'agents telles que le nombre
minimum, maximum et moyen de pas, la taille de la mémoire des
agents, le nombre d'agents créés, tués, etc. Pour ce faire,
de nouvelles classes en fonction de la nature des statistiques ont
été ajoutées.

\begin{figure}[!ht]
  \center
  \includegraphics[width=14cm]{images/statistiques.png}
  \caption{Statistiques en temps réel dans Visidia}
  \label{fig:statistiques}
\end{figure}



\section{Implémentation d'algorithmes}

\subsection{Fusion des mémoires}
Dans cet algorithme, les agents se déplacent de manière synchrone. Ils se rencontrent 
sur les sommets (où ils ont le choix de rester sur place ou de se déplacer au prochain 
\texttt{top}), l'agent dont l'identificateur est le plus grand récupère la mémoire des
 autres agents du même type présents sur le sommet et les autres agents sont tués.\\



Au niveau de l'implémentation, nous avons effectué les choix suivants : chaque agent, 
lorsqu'il arrive sur un sommet, met dans le \textit{whiteboard} de ce sommet son identifiant 
seulement si le sien est plus grand, et attend que tous les autres agents l'aient fait. 
Ensuite, il compare son identifiant $ID$ avec celui du sommet (contenant donc le plus grand
 identifiant $maxID$ de tous les agents présents sur le sommet) : si $ID < maxID$, alors 
 l'agent fusionne sa mémoire dans celle du sommet puis se tue. L'unique agent tel 
 que $ID = maxID$ récupère alors la fusion des mémoires contenue dans le sommet avant 
 de réinitialiser la mémoire du sommet puis de se déplacer avec une probabilité égale à un tiers.




\subsection{Algorithme auto-stabilisant : agent sur un anneau}

Cet algorithme est la traduction dans le language propre à \visidia de
l'algorithme suivant en considérant $i$ comme sommet courrant, $St(i)$ la variable
$St$ du sommet $i$, et, $St$ et $Token$ deux variables de l'agent~:
\begin{itemize}
  \item \textbf{$R_0$~:} if($i$ = 0); $St$=$St(0)$; $Token$=false; move($i$+1 mod N);
  \item \textbf{$R_1$~:} if ($St$ != $St(i)$ and ! $Token$) then $St$=$St(i)$;
  Token=true; move(i+1 mod N);
  \item \textbf{$R_2$~:} if ($St$ != $St(i)$ and $Token$) then $St(i)$=$St$; move($i$+1 mod N
  );
  \item \textbf{$R_3$~:} if ($St$ == $St(i)$) then move($i$+1 mod N) ;
\end{itemize}


\subsection{Calcul d'arbre recouvrant distribué auto-stabilisant}

\subsubsection{Hypothèse relative au développement}
 
\begin{itemize}
  \item Agent identifiés par un identifiant unique
  \item Relation d'ordre entre les identifiants des agents
  \item Sommet identifiés par un identifiant unique (hypothèse pouvant êter
  retirée) 
  \item Connaissance du nombre de sommets du graphe
  \item Asynchrone
\end{itemize}

\subsubsection{Principe de fonctionnement}

Le but de l'algorithme est de calculer un arbre couvrant sur un graphe, à partir
de plusieurs agents réparti sur des sommets celui-ci. Les agents devant
collaborer de manière à ce que lors de la terminaison seul un arbre couvrant
soit présent.\\

Pour cela, les agents se mettent chacun de leur côté à calculer un arbre recouvrant.
En cas de rencontre par un agent d'un sommet appartenant à un arbre de plus
petit identificateur, l'agent de plus grand identificateur annexe à son propre sous-arbre 
le sous-arbre calculé par l'agent de plus petit identificateur et ce en 
envoyant un clone pour faire le rapatriement. A la fin, il ne reste qu'un 
seul agent, c'est lui qui a annexé les autres sous-arbres calculés.
L'arbre regrouvant calculé par cet agent est, donc, un arbre recouvrant
de tout le graphe.\\

Afin de tester la terminaison de l'agorithme, a chaque passage par la racine du
sous-arbre en cours de calcul, l'agent lance un parcours en profondeur sur ce
dernier. Si le nombre de sommets rencontrés durant le parcours est égale au
nombre de sommets du graphe, l'algorithme est terminée.\\

Le détail du fonctionnement de l'algorithme se trouve en annexe.

\subsubsection{Implémentation}

Nous avons commencé par diviser le problème en trois sous 
problèmes: calculer un arbre recouvrant, annexer un sous-arbre 
et détecter la terminaison.


\begin{itemize}

\item Nous avons implémenté un agent qui calcule un arbre recouvrant \textit{Spanning\_Tree\_Agent}
en laissant des traces sur les sommets visités lui indiquant son père et ses
fils relatif à l'arbre calculé par l'agent. Chaque sommet peut ainsi avoir une
idée de sa position dans l'arbre. \\ 
C'est grâce à ces tracer que les clones lancés par les agents pour annexer un
sous arbre et l'agent chargé de calculer la terminaison de l'algorithme peuvent
effectuer un parcours en profondeur et donc fonctionner correctement.

L'agent termine sa vie lorsqu'il rencontre un sommet appartenant à un arbre
d'identifiant plus fort, ou également lorsqu'il rencontre un agent \textit{Spanning\_Tree\_Agent}
d'identifiant plus fort, ou enfin si il détecte que l'arbre couvrant est terminé.

\item Nous avons également implémenté un agent qui parcourt en profondeur 
un arbre recouvrant, c'est l'agent \textit{Depth\_Traversal\_Agent}. Son rôle est 
de détecter la terminaison de l'algorithme. A chaque fois que l'agent
\textit{Spanning\_Tree\_Agent} passe par sa racine, il créait un agent \textit{Depth\_Traversal\_Agent}
et lui indique l'identifiant de l'arbre qu'il doit parcourir. L'agent
\textit{Spanning\_Tree\_Agent} se veille dans le sommet en attendant le résultat
de l'agent \textit{Depth\_Traversal\_Agent}. Lorsque ce dernier à fini (il se trouve donc sur la racine avec l'autre
agent) il transmet le nombre de sommet du sous arbre parcouru et meure. Si le
nombre calculé est le nombre de sommet du graphe, le sous arbre est un arbre
couvrant et l'agent \textit{Spanning\_Tree\_Agent} se termine à son tour.
 

\item Pour annexer un sous arbre, nous avons implémenté un agent
\textit{Annexing\_SubTree\_Agent}, aussi appelé $clone$.
Ce dernier est créé par un agent \textit{Spanning\_Tree\_Agent} afin d'annexer un
sous arbre d'identifiant inférieur. L'identifiant de l'abre à étendre est
l'identifiant de l'arbre auquel appartient le sommet où est créé l'agent;
l'identifiant de l'abre à annexer est fourni par le créateur de l'agent.\\

Le clone effectue un parcours en profondeur sur l'abre qu'il doit annexer à
l'aide des tracer laissées par l'agent \textit{Spanning\_Tree\_Agent} ayant créé
l'arbre. A chaque sommet visité l'agent étend l'arbre de plus fort identifiant
en changeant la couleur du sommet (identifiant l'arbre auquel il appartient). A
chaque modification du graphe il est primoridial de garder l'arbre dans un étant
cohérent notamment en évitant de créer des cycles.\\

 Il se tue quand il atteint la racine du sous-arbre à annexer ou quand il
 va sur un sommet qui a été déjà annexé par un agent de plus grand identificateur.

\end{itemize} 

La réalisation de cet algorithme a été particulièrement difficile car de
nombreux
cas particuliers liés à l'implémentation sous \visidia se sont présentés. Un
survol des sources des agents présents en annexe permet d'avoir un aperçu des
différents cas identifiés.\\

\begin{figure}[!ht]
  \center
  \includegraphics[width=14cm]{images/structureAgents.png}
  \caption{Relations entre les agents}
  \label{fig:structureAgents}
\end{figure}