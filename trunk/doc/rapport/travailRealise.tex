\section{Ajout de fonctionnalités}

\subsection{Modification du graphe en cours d'exécution}

\subsubsection{Structure du graphe}

Dans visidia, il y a une séparation totale entre la partie affichage et la
partie simulation. Ainsi, \visidia manipule deux graphes : un graphe visuel et un
autre pour la simulation.\\

N'ayant aucune indication sur les structures de ces graphes, on pouvait imaginer
que les structures de ces graphes pouvaient être les mêmes, ou bien avoir des
points en commun.\\

Aprés une analyse plus poussé du code, nous avons découvert que les deux
structures étaient totalement dissociés et indépendante l'une de l'autre.
Pour la partie simulation, le répertoire ``graph'' contient toutes les classes
de l'architecture du graphe.
%inclure schéma architecture

Pour la partie affichage, le repertoire ``gui.presentation'' contient les
classes implémentant la structure du graphe visuel.


\subsubsection{Choix de développement}

Lors de la conception de \visidia, il n'a pas été prévu que le graphe visuel
puisse évoluer au cours de la simulation.
En effet, aucune intéraction entre les deux graphes n'a été envisagés hormis, la
conversion d'un graphe visuel en un graphe de simulation par l'intermédiaire de
la classe ``Convertisseur''et de sa méthode ``convert".\\

En effet, le graphe visuel dessiné dans l'application principale est converti
un graphe simulation au moment du passage vers l'application ``simulation avec
agents''. 
Aprés cette manipulation le graphe visuel étant présumé statique, aucune méthode
agissant sur le graphe dessiné, ne répercutait les modifications sur le graphe de
simulation et vice versa.\\

Une solution possible à laquelle nous avions pensé, et qui permettait de
réutiliser ce qui avait été développé jusqu'à présent, était de
convertir le graphe visuel vers un graphe simulation à chaque fois que l'on
modifiait le graphe visuel. 
Nous n'avons cependant pas choisi d'implémenter cette méthode pour des raisons
évidentes de performance: la génération d'un nouveau graphe de simulation à
chaque ajout ou suppression d'arêtes ou sommet peut s'averer tres couteux,
surtout avec un graphe de grande taille. \\

Ainsi donc nous avons préféré pour chaques modifications possible sur le graphe visuel, 
implémenter une méthode permettant de répercuter les effets sur le graphe de simulation.

\subsubsection{Ajout de sommets et d'arêtes}

L'ajout de sommets et d'arêtes sur le graphe visuel avait déjà été implémenté
pour la fenetre principale de \visidia. Nous avons donc récupérer ce code, pour
l'adapter à l'application de simulation avec agents.\\

Nous avons ensuite implémenté une méthode addVertex() et addEdge() pour la
classe AgentSimulationWindow qui pour
chaque sommet, respectivement chaque arête, que l'on souhaite ajouter au graphe
visuel, effectue l'opération et répercute la modification sur le graphe
simulation.

\subsubsection{Suppression de sommets et d'arêtes}

La suppression de sommet et d'arêtes a été plus délicate à gerer que l'ajout
puisque au moment où l'on souhaite retirer une arête ou un sommet, il est
possible qu'un agent soit sur l'élément considéré. Il faut donc pouvoir détecter
la présence d'un ou plusieurs agents sur un objet donné, et ensuite pouvoir le
ou les détruire en même temps que la suppression du sommet ou de l'arête.\\

Nous avons donc implémenté les méthodes removeVertex() et removeEdge() pour la
classe AgentSimulationWindow qui pour
chaque sommet, respectivement chaque arête, que l'on souhaite supprimer du graphe
visuel,effectue l'opération et répercute la modification sur le graphe
simulation. Ces deux méthodes font appel à la méthode 

Nous avons également ajouté à la classe AgentSimulator, les méthodes
deleteVertex et deleteEdge() qui réalise la suppression du simulateur d'un
sommet, respectivement d'une arête, tout en gérant le cas où un agent serait présent.


\subsection{Ajout et suppression d'agent en cours d'exécution}

\subsubsection{Ajout d'agents en cours d'exécution}
L'ajout d'agents sur le graphe avait déjà été implémenté avant la simulation. Nous avons donc récupéré le code existant pour l'adapter à l'application en cours d'exécution.\\

Après sélection d'un sommet, l'utilisateur utilise le menu d'ajout d'agents. A ce moment, l'identificateur du sommet est récupéré, et le nouvel agent est ajouté dans la table de hachage des agents avec la méthode \textit{addAgents()}. Une méthode \textit{createAgentDuringExecution()} a été créée dans le simulateur afin de créeer effectivement l'agent sur le sommet sélectionné et afin de créer et lancer un \textit{thread} pour l'agent nouvellement ajouté.


\subsubsection{Suppresion d'agents en cours d'exécution}
Un bouton a été ajouté dans la fenêtre de simulation afin de permettre la suppression d'agents en cours d'exécution. Lorsque l'utilisateur active cette fonctionnalité, l'ensemble des agents en cours d'exécution est récupéré. L'utilisateur sélectionne ensuite le nom de l'agent qu'il souhaite supprimer : cette action fait alors appel à une méthode \textit{killAgent} qui a été créée dans le simulateur. En effet, les fonctions de bases déjà présentes dans l'application \visidia ne permettaient pas de tuer proprement un agent, sans que celui-ci termine son déplacement jusqu'au prochain sommet si par exemple l'agent était tué alors qu'il se déplaçait sur une arête.\\

La méthode implémentée ci-dessus supprime le \textit{thread} associé à l'agent et enlève ce dernier de la table de hachage des agents. Enfin, afin que ces modifications soient prises en compte dans la fenêtre de simulation, l'agent est également supprimé de la file d'évènements envoyés à l'interface graphique.




\subsection{Modification des mémoires}

Le but de la modification de la mémoire des agents et des sommets est 
de simuler des erreurs. Donc, grâce à cette fonctionnalité, l'utilisateur 
peut modifier les valeurs des variables qui peuvent influencer le déroulement
des algorithmes. Ceci suppose qu'il a déjà stocké ces variables dans 
le whiteboard du sommet ou de l'agent.

\subsubsection{Modification de la mémoire des sommets}

En effet, les variables dont la modification des valeurs peut corrompre 
l'exécution des algorithmes varient suivant ces derniers. Cependant, 
il existe des variables qui peuvent engendrer des erreurs et ce quelque 
soit l'algorimthe: leur modification peut affecter le déroulement de tous 
les algorithmes. Ces variables sont le booléen \textit{Visualisation} 
et le String \textit{label} La première indique qu'un sommet est éteint quand 
elle est à \textit{false} et allumé si elle est à \textit{true}. La seconde variable 
indique la couleur du sommet. Ces deux variables sont par défaut stockées 
dans la mémoire des sommets.\\

 Si l'utilisateur souhaite pouvoir modifier 
d'autres variables pour simuler des erreurs, il n'a qu'à stocker ces variables
dans le whiteboard en appellant les méthodes adéquates de la classe \textit{WhiteBoard}.
Cette fonctionalité de la modification de la mémoire a été implémentée de manière 
que toute modification de ces variables à travers la fenêtre de dialogue sera 
prise en compte et se répercute sur le déroulement de l'algorithme.
 
\subsubsection{Modification des mémoires des agents}

Dans le cas des agents, il n'y a pas des variables communes à tous les algorithmes.
L'utilisateur est alors invité à ajouter les variables de son choix dans le whiteboard.
Bien évidemment, comme pour la mémoire des sommets, leur modification à travers la fenêtre 
de dialogue sera prise en compte et se répercutera sur le déroulment de l'agorithme.\\

Dans la version des algorithmes que nous avons reprise, les variables utlisées par
l'agent sont déclarées en tant que variables locales de la méthode init(). 
Ce qui fait qu'avec cette implémentation simuler des erreurs en modifiant 
les valeurs de ces variables ne soit pas possible. Donc, pour remedier à ce problème,
nous avons envisagé deux solutions possibles:
\begin{itemize}

\item Pour chaque algorithme, stocker et initialiser ces variables dans 
le whitebord. A chaque fois qu'elles sont utilisées, on doit les mettre 
à jour en reprenant la valeur la plus récente à partir du whiteboard. 
Ceci permet de prendre en compte les modifications "manuelles" apportées par
l'utilisateur et donc de simuler des erreurs. L'inconvénient de cette solution 
est qu'avant chaque instruction manipulant ces variables nous sommes 
obligés d'ajouté une instruction de mise à jour.


\item Utiliser une méthode \textit{initWhiteBoard()} qu'on implémente dans chaque
nouvelle classe définissant un nouveau agent. Son implémentation consiste en
le stockage et l'initialisation des variables que l'utilisateur souhaite modifier. 
Cette méthode ne peut pas être une méthode abstraite de la classe \textit{Agent} 
car sinon cela imposera que cette méthode soit implémentée dans toutes 
les sous-classes, ce qui entraînera des modifications considérables du code
des algorithmes: mettre toutes ces variables qui sont locales en tant qu'attributs
de l'agent en question et, par conséquent, modifier toutes les instructions les manipulant.
En plus, cela dépendra des choix de l'utilisateur notamment du choix des variables
qu'il souhaite modifier, ces variables variant suivant les algorithmes et suivant ses besoins. 

\end{itemize}

Pour garantir une evolutivité ascendante du code, la première solution a été retenue 
pour les algorithmes déjà implémentés alors que pour les algorithmes que nous avons
codés, nous avons retenu la deuxième solution qui nous semble la plus pertinente. 


\subsection{Extinction et allumage des sommets}

Cette fonctionalité permet à l'utilisateur de mettre à l'écart un sommet
sans le supprimer du graphe. L'exécution des algorithmes se fait comme si le sommet
n'existait pas. Pour indiquer qu'un sommet est éteint, on le colorie en gris
et on lui met l'étiquette \textit{Switch Off}. Bien évidemment, une fonctionalité 
a été implémentée pour réallumer le sommet. Quand ce dernier est rallumé 
il reprend la couleur et l'étiquette qu'il avait avant son extinction.\\

%%%cette partie est à développer d'avantage!!!!
Cependant, l'extinction d'un sommet necéssite, dans certains cas, des traitements 
spéciaux pour les agents. Si un agent se dirige vers un sommet qu'on vient d'éteindre, 
il revient d'où il vient. Si l'agent se trouve sur une arête incidente à deux sommets
éteints l'agent se tue.



\subsection{Calcul des statistiques en temps réel}
Afin de disposer de statistiques en temps réel, nous avons ajouté une méthode \textit{makeStatOnMove} dans le simulateur qui est appelée à chaque déplacement d'un agent. La classe utilise la classe de statistiques, déjà existante, nommée \textit{Bag} à laquelle on a ajouté des fonctions de base de calcul de minimum et de maximum.\\

C'est dans la nouvelle méthode \textit{makeStatOnMove} du simulateur qu'ont été implémentées les nouvelles statistiques sur les agents et classes d'agents telles que le nombre minimum, maximum et moyen de pas, la taille de la mémoire des agents, le nombre d'agents créés, tués, etc.




\section{Implémentation d'algorithmes}

\subsection{Fusion des mémoires}
Dans cet algorithme, les agents se déplacent de manière synchrone. Ils se rencontrent sur les sommets (où ils ont le choix de rester sur place ou de se déplacer au prochain \texttt{top}), l'agent dont l'identificateur est le plus grand récupère la mémoire des autres agents du même type présents sur le sommet et les autres agents sont tués.\\

Au niveau de l'implémentation, nous avons effectué les choix suivants : chaque agent, lorsqu'il arrive sur un sommet, met dans le whiteboard de ce sommet son identifiant seulement si le sien est plus grand, et attend que tous les autres agents l'aient fait. Ensuite, il compare son identifiant $ID$ avec celui du sommet (contenant donc le plus grand identifiant $maxID$ de tous les agents présents sur le sommet) : si $ID < maxID$, alors l'agent fusionne sa mémoire dans celle du sommet puis se tue. L'unique agent tel que $ID = maxID$ récupère alors la fusion des mémoires contenue dans le sommet avant de réinialiser la mémoire du sommet puis de se déplacer avec une probabilité égale à un tiers.



\subsection{Algorithme auto-stabilisant : agent sur un anneau}

\subsection{Calcul d'arbre recouvrant distribué}